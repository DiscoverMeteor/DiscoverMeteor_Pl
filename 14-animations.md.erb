---
title: Animacje
slug: animations
date: 0014/01/01
number: 14
contents: Co dzieje się za kulisami Meteora podczas zamiany dwóch elementów DOM.|Jak animować zmianę kolejności postów.|Jak animować wstawianie nowych postów.
paragraphs: 58
---

Opanowaliśmy już głosowanie w czasie rzeczywistym, punktację i ranking. Niestety te usprawnienia doprowadziły do nieprzyjemnego interfejsu użytkownika, ponieważ posty skaczą po stronie głównej. Użyjemy animacji aby pozbyć się tego efektu i wygładzić interfejs. 

### Meteor i DOM

Zanim dojdziemy do prawdziwej zabawy (przemieszczania elementów na stronie), należy zrozumieć jak Meteor współpracuje z DOM (ang. Document Object Model -- kolekcją elementów HTML które składają się na zawartość strony).

Główną zasadą o której należy pamiętać jest to, że elementy DOM *nie mogą się przemieszczać*. Mogą być wyłącznie usuwane i tworzone (miej na uwadze, że jest to ograniczenie DOM, a nie Meteora). Aby więc spowodawać iluzję zamiany elementów A i B Meteor usunie element B i wstawi całkiem nową kopię (B') przed elementem A.

Nie ułatwia to animacji, ponieważ nie można po prostu animować elementu B na nową pozycję, ponieważ B zniknie zaraz po przerenderowaniu strony (co jak wiemy dzieje się natychmiastowo dzięki reaktywności). Zamiast tego należy animować nowo stworzony B', który przemieszcza się z początkowej pozycji B' do nowej pozycji przed elementem A.

Aby zamienić miejscami posty A i B (umieszczone w miejscach odpowiednio p1 i p2) przejdziemy przez kolejne kroki:

1. Usunięcie B
2. Utworzenie B' przed A w DOM
3. Przesunięcie B' na pozycję p2
4. Przesunięcie A na pozycję p1
5. Animowanie A na pozycję p2
6. Animowanie B' na pozycję p1

Poniższy diagram wyjaśnia szczegółowo te kroki:

<%= diagram "animation_diagram", "Zamiana dwóch postów", "pull-center" %>

Miej na uwadze, że dla kroków 3 i 4 nie *animujemy* A i B' do ich pozycji ale "teleportujemy" je natychmiastowo. Ponieważ dzieje się to natychmiastowo, daje to iluzję tego, że element B nie został usunięty i odpowiednio umieści oba elementy do annimacji na nowe pozycje.

Na szczęście Meteor zatroszczy się za nas o kroki 1 & 2, zatem musimy martwić się wyłącznie o kroki od 3 do 6.

Co więcej, w krokach 5 i 6 wszystko co robimy, to przesuwanie elementów do ich docelowych miejsc. W związku z tym musimy się martwić wyłącznie o kroki 3 i 4 tj. wysłanie elementów do startowych punktów animacji.

### Dopasowanie czasu animacji

Do tej pory mówiliśmy o tym *jak* animować posty ale nie *kiedy* je animować.

Dla kroków 3 i 4 odpowiedź brzmi: podczas renderowania callback'a `rendered` szablonu w środku managera `post_item.js`, który jest wywoływany przy każdej zmianie własności posta (w naszym przypadku rankingu).

Kroki 5 i 6 są bardziej podchwytliwe. Pomyśl o nich w następujący sposób: jeżeli każesz perfekcyjnie myślącemu robotowi poruszać się na północ przez 5 minut, a następnie po zakończeniu poruszać się na południe przez 5 minut, prawdopodobnie wydedukował by, że skończy w tej samej pozycji i zamiast martwić swoją energię wcale nie zmieniłby pozycji.

Jeżeli chcesz się upewnić, że robot będzie się poruszał przez całe 10 minut, należy *poczekać* aż przebył pierwsze 5 minut, i *wtedy* kazać mu wrócić.

Przeglądarka działa w podobny sposób: jeżeli damy jej 2 instrukcje jednocześnie, nowe współrzędne zajmą miejsce starych i nic by się nie wydarzyło. Inaczej mówiąc, nie bylibyśmy w stanie ich animować.

Meteor nie zapewnia callbacka `justAfterRendered` (ang. `zaraz po renderowaniu`), ale możemy go symulować używając `Meteor.defer()` który bierze funkcję i odracza jej wykonanie aż do momentu zarejestrowania jej jako inne zdarzenie.

### Pozycjonowanie CSS

Aby animować posty, które są zamieniane kolejnością na stronie, musimy wejść w terytorium CSS. W związku z tym szybko przedstawimy umieszczanie elementów za pomocą CSS.

Elementy na stronie domyślnie używają **statycznego** pozycjonowania. Statycznie pozycjonowane elementy naturalnie wpasowują się w stronę i ich współrzędne nie mogą być zmieniane lub animowane.

**Względne** pozycjonowanie oznacza z innej strony, że element także jest naturanie wpasowany w stronę, ale może być umieszczony z przesunięcięm *względnym do pozycji początkowej*.

**Bezwzględne** pozycjonowanie idzie o jeden krok dalej i pozwala nadać określony współrzędne x/y dla danego elementu względnie do punktu początkowego **dokumentu** lub **pierwszego bezwzględnego lub względnie przesuniętego elementu nadrzędnego**.

Użyjemy pozycjonowania względnego aby animować posty. Zatroszczyliśmy się za Ciebie o kod CSS, ale jeżeli chcesz to zrobić sam, wystarczy dodać poniższy kod do arkusza stylów (ang. stylesheet):

~~~css
.post{
  position:relative;
  transition:all 300ms 0ms ease-in;
}
~~~
<%= caption "client/stylesheets/style.css" %>

Ułatwia to znacznie kroki 5 i 6: wszystko co należy zrobić, to ustawić `top` na `0px` (wartość domyślną) i nasze posty automatycznie przesuną się na ich "normalną" pozycję.

Oznacza to, że jedynym wyzwaniem jest znalezienie miejsca *z którego* je animować (kroki 3 i 4) względnie do ich nowej pozycji. Mówiąc inaczej jak bardzo je przesunąć. Nie jest to również trudne: prawidłowy offset to po prostu poprzednia pozycja postu minus jego nowa pozycja.

<% note do %>

### Pozycja bezwględna (Position:absolute)

Moglibyśmy również użyć `position:absolute` z względnym elementem nadrzędnym do pozycjonowania elementów. Wielkim minusem bezwzględnie pozycjonowanych elementów jest to, że są całkowicie usuwane z przepływu strony, powodując zwinięcie nadrzędnego kontenera tak jak gdyby byłby pusty.

To w konsekwencji oznacza, że potrzebowalibyśmy sztucznie ustawić wysokość kontenera za pomocą JavaScript zamiast postawić przeglądarce na naturalne rozmieszczenie elementów. W związku z tym, gdzie tylko można najlepiej używać pozycjonowania względnego.

<% end %>

### Pamięć absolutna.

Pozostaje jeszcze jeden problem. Podczas gdy element A zostaje w DOM i może dzięki temu "pamiętać" poprzednią pozcyję, element B przeżywa reinkarnację jako element B' i ma wyczyszczoną pamięć o poprzedniej pozycji.

Na szczęście Meteor radzi sobie z tym problemem przez udostępnienie objektu **instancji szablonu** w callbacku `rendered`. Za oficjalną [dokumentacją Meteora](http://docs.meteor.com/#template_rendered):

> W callbacku `this` odności się do obiektu instancji szablonu, który jest unikatowy do tego wystąpienia szablonu i zachowany przy renderowaniu.

Zatem co zrobimy, to odnajdziemy obecną pozycję posta na stronie i następnie zapamiętamy tą pozycję w obiekcie instancji szablonu. W ten sposób, nawet wtedy gdy post jest usuwany i ponownie tworzony jesteśmy w stanie określić skąd go animować.

Instancje szablonu pozwalają również na dostęp do danych kolekcji przez własność `data`. Okaże się to pomocne do ustalenia rankingu posta.

### Ranking Postów

////

////

////

////

~~~js
Template.postsList.helpers({
  postsWithRank: function() {
    this.posts.rewind();
    return this.posts.map(function(post, index, cursor) {
      post._rank = index;
      return post;
    });
  }
});
~~~
<%= caption "/client/views/posts/posts_list.js" %>
<%= highlight "2~8" %>

////

////

~~~html
<template name="postsList">
  <div class="posts">
    {{#each postsWithRank}}
      {{> postItem}}
    {{/each}}
    
    {{#if nextPath}}
      <a class="load-more" href="{{nextPath}}">Load more</a>
    {{/if}}
  </div>
</template>
~~~
<%= caption "/client/views/posts/posts_list.html" %>

<%= highlight "3" %>

<% note do %>

### Przewiń wstecz

////

////

////

<% end %>

### Wszystko razem

////

~~~js
Template.postItem.helpers({
  //...
});

Template.postItem.rendered = function(){
  // animacja postu na nową pozycję
  var instance = this;
  var rank = instance.data._rank;
  var $this = $(this.firstNode);
  var postHeight = 80;
  var newPosition = rank * postHeight;
 
  // jeżeli element posiada currentPosition (tzn. nie jest pierwszy raz renderowany)
  if (typeof(instance.currentPosition) !== 'undefined') {
    var previousPosition = instance.currentPosition;
    // oblicz różnicę między starą i nową pozycją i wyślij tam element
    var delta = previousPosition - newPosition;
    $this.css("top", delta + "px");
  }
  
  // rysuj w starej pozycji..
  Meteor.defer(function() {
    instance.currentPosition = newPosition;
    // przenieś element na pozycję początkową
    $this.css("top",  "0px");
  }); 
};

Template.postItem.events({
  //...
});
~~~
<%= caption "/client/views/posts/post_item.js" %>
<%= highlight "5~27" %>

<%= commit "14-1", "Dodano animację uporządkowania postów." %>

////

////

////

### Animacja Nowych Postów

////

////

1. ////
2. ////

////

////

~~~js
Template.postItem.helpers({
  //...
});

Template.postItem.rendered = function(){
  // animacja postu na nową pozycję
  var instance = this;
  var rank = instance.data._rank;
  var $this = $(this.firstNode);
  var postHeight = 80;
  var newPosition = rank * postHeight;
  
  // jeżeli element posiada currentPosition (tzn. nie jest pierwszy raz renderowany)
  if (typeof(instance.currentPosition) !== 'undefined') {
    var previousPosition = instance.currentPosition;
    // oblicz różnicę między starą i nową pozycją i wyślij tam element
    var delta = previousPosition - newPosition;
    $this.css("top", delta + "px");
  } else {
    // jest to pierwsze renderowanie, więc ukryj element
    $this.addClass("invisible");
  }
  
  // rysuj w starej pozycji..
  Meteor.defer(function() {
    instance.currentPosition = newPosition;
    // przenieś element na pozycję początkową
    $this.css("top",  "0px").removeClass("invisible");
  }); 
};

Template.postItem.events({
  //...
});
~~~
<%= caption "/client/views/posts/post_item.js" %>
<%= highlight "19~22,28" %>

<%= commit "14-2", "Ściemnianie elementów po narysowaniu." %>

////

<% note do %>

### CSS i JavaScript

////

////

<% end %>

////
