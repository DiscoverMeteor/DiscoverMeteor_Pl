---
title: Zaawansowana reaktywność
slug: advanced-reactivity
date: 0011/01/02
number: 11.5
sidebar: true
contents: jak tworzyć reaktywne źródła danych w Meteorze.| jak zaimplementować prosty przykład reaktywnego źródła danych.| jak zależności (Deps) mają się do AngularJS.
paragraphs: 29
---

Żadko zachodzi potrzeba do napisania samemu kodu do śledzenia zależności, ale z pewnością warto zrozumieć ten mechanizm aby śledzić sposób jego działania.

Wyobraź sobie, że chcemy śledzić liczbę przyjaciół danego użytkownika Facebooka, którzy 'polubili' każdy post na Microscope. Przyjmijmy, że już zaimplementowaliśmy logowanie użytkownika za pomocą Facebooka, wywołaliśmy odpowiednie funkcje API i parsowaliśmy odpowienie dane. Posiadamy asynchroniczną funkcję po stronie klienta, która zwraca liczbę polubień posta, `getFacebookLikeCount(user, url, callback)`.

Ważną sprawą do zapamiętania jest, jak taka funkcja jest *niereaktywna* i w jakim stopniu nie jest czasu rzeczywistego. Funkcja wywoła żądanie HTTP do Facebooka, odczyta trochę danych i udostępni je aplikacji w asynchronicznym callbacku. Nie wywoła się ponownie sama gdy liczba polubień ulegnie zmianie i nasze UI nie uaktualni się podczas zmiany danych.

Aby to naprawić, możemy zacząć przez ustawienie `setInterval` aby wołać funkcję co kilka sekund.

~~~js
currentLikeCount = 0;
Meteor.setInterval(function() {
  var postId;
  if (Meteor.user() && postId = Session.get('currentPostId')) {
    getFacebookLikeCount(Meteor.user(), Posts.find(postId), 
      function(err, count) {
        if (!err)
          currentLikeCount = count;
      });
  }
}, 5 * 1000);
~~~

Za każdym razem, gdy sprawdzamy zmienną `currentLikeCount`, możemy oczekiwać na zwrócenie prawidłowej liczby z pięciosekundowym marginesem błędu. Możemy użyć tą zmienną w helperze jak poniżej:

~~~js
Template.postItem.likeCount = function() {
  return currentLikeCount;
}
~~~

Jednak nic nie wywołuje renderowania szablonu po zmianie `currentLikeCount`. Pomimo tego, że zmienna ta jest pseudo- czasu rzeczywistego, nie jest jeszcze *reaktywna* i nie może się w odpowiedni sposób komunikować z resztą ekosystemu Meteora.

### Śledzenie reaktywności: Obliczenia

Reaktywność Meteora działa za pośrednictwem *zależności*, struktur danych, które śledzą zbiór komputacji.

Jak widzieliśmy we wcześniejszym pasku bocznym reaktywności, komputacja jest blokiem kodu, który używa reaktywnych danych. W naszym przypadku istnieje komputacja pośrednio utworzona dla szablonu `postItem`. Każdy helper managera tego szablonu pracuję z tą komputacją.

Możesz myśleć o komputacji, jako o sekcji kodu, która "troszczy się" o reaktywne dane. Gdy dane zmieniają się, to ta komputacja zostaje o tym poinformowana (przez `invalidate()`) i to ta komputacja decyduje o tym, czy wykonać jakąś akcję.

### Przemiana zwykłej zmiennej w funkcję reaktywną

Aby zmienić naszą zmienną `currentLikeCount` w reaktywne źródło danych, musimy śledziź wszystkie komputacje, które używają jej w zależności. Wymaga to zmiany ze zmiennej na funkcję (która zwróci wartość):

~~~js
var _currentLikeCount = 0;
var _currentLikeCountListeners = new Deps.Dependency();

currentLikeCount = function() {
  _currentLikeCountListeners.depend();
  return _currentLikeCount;
}

Meteor.setInterval(function() {
  var postId;
  if (Meteor.user() && postId = Session.get('currentPostId')) {
    getFacebookLikeCount(Meteor.user(), Posts.find(postId), 
      function(err, count) {
        if (!err && count !== _currentLikeCount) {
          _currentLikeCount = count;
          _currentLikeCountListeners.changed();
        }
      });
  }
}, 5 * 1000);
~~~
<%= highlight "1~7,14~17" %>

Co osiągneliśmy to ustawienie zależności `_currentLikeCountListeners`, która śledzi wszystkie komputacje w której użyty był `currentLikeCount()`. Gdy wartość `_currentLikeCountListeners` ulega zmianie, wołamy funkcję `changed()` na tej zależności, która unieważnia wszystkie śledzone komputacje.

Wtedy komputacje mogą kontynuować i reagować na zmiany odpowiednio do każdego przypadku. W przypadku komputacji szablonu oznacza to, że szablon się renderuje.

### Obliczenie szablonów i kontrola ich renderowania

////

////

////

////

////

////

### Porównianie zależności (Deps) do Angular.js

////

////

////

////

////

////

~~~js
$rootScope.$watch('currentLikeCount', function(likeCount) {
  console.log('Current like count is ' + likeCount);
});
~~~

////

////

////

////

~~~js
Meteor.setInterval(function() {
  getFacebookLikeCount(Meteor.user(), Posts.find(postId), 
    function(err, count) {
      if (!err) {
        $rootScope.currentLikeCount = count;
        $rootScope.$apply();
      }
    });
}, 5 * 1000);
~~~
<%= highlight "5~6" %>

////
