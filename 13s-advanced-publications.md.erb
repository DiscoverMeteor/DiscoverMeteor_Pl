---
title: Zaawansowane publikacje
slug: advanced-publications
date: 0013/01/02
number: 13.5
sidebar: true
contents: o zaawansowanych metodach zarządzania publikacjami.|o możliwościach jakie oferują publikacje i subskrypcje. 
paragraphs: 36
---

Do tej pory powinieneś się zaznajomić ze sposobem działania publikacji i subskrypcji. Czas zatem przejść do bardziej zaawansowanych scenariuszy.
 
### Wielokrotne publikowanie kolekcji

W [rozdziale wprowadzającym publikacje i subskrypcje](/chapter/publications-and-subscriptions/) poznałeś niektóre ze wzorów stosowania publikacji i subskrypcji i nauczyłeś jak funkcja `_publishCursor` ułatwia ich implementacje podczas tworzenia własnych stron.
 
Przypomnijmy sobie, co funkcja `publishCursor` faktycznie wykonuje: zbiera wszystkie dokumenty, które pasują do kursora i wysyła je do kolecji po stronie klienta która *ma tą samą nazwę*. Zauważ, że nazwa _publication_ nie jest w żaden sposób wymieniona.
 
Oznacza to, że możemy mieć _więcej niż jedną pulikację_ łączącą wersję jakichkolwiek kolekcji po stronie klienta i serwera.
 
Spotkaliśmy się już z tym wzorcem w [rozdziale Dzielenie dokumentu na strony](/chapter/pagination/), gdzie publikowaliśmy dzielony podzbiór wszystkich postów w dołączonych do bieżącego posta.
 
Innym podobnym zastosowaniem publikacji jest publikacja *przeglądu* większego zbioru dokumentów, jak również szczegółów pojedyńczego elementu.
 
<%= diagram "doublecollection", "Dwukrotne publikowanie kolekcji", "pull-center" %>

~~~js
Meteor.publish('allPosts', function() {
  return Posts.find({}, {fields: {title: true, author: true}});
});

Meteor.publish('postDetail', function(postId) {
  return Posts.find(postId);
});
~~~

W momencie gdy klient subskrybuje powyższe dwie publikacje (używając `autorun` aby upewnić się, że właściwy `postId` jest wysyłany do subskrypcji `postDetail`), jego kolekcja `posts` jest uaktualniana danymi pochodzącymi z dwóch źródeł: listy tytułów i nazwisk autorów z pierwszej subskrypcji i pełnymi szczegółami posta z drugiej.

Możesz zdać sobie sprawę, że post publikowany przez `postDetail` jest również publikowany przez `allPosts` (pomimo tego, że jedynie z podzbiorem jego danych). Jednakże, Meteor troszczey się o łączeniu pól i upewnienia się, żeby żaden post nie był duplikowany.

Jest to bardzo duże ułatwienie, ponieważ w tym przypdaku gdy renderujemy listę streszczeń postów, mamy do czynienia z obiektami danych które mają tylko tyle danych do pokazania, ile potrzeba. Jednakże podczas renderowania strony dla pojedyńczego posta, mamy wszystkie potrzebne dane. Oczywiście musimy wziąć pod uwagę, żeby nie oczekiwać po stronie klenta dostępności wszystkich pól we wszystkich postach - jest to częste źródło nieporozumień i błędów.
 
Należy odnotować, że nie jesteś ograniczony do zmieniających się właściwości dokumentu. Mógłbyś równie dobrze publikować te same własności w obu publikacjach ale uporządkować je w inny sposób.
 
~~~js
Meteor.publish('newPosts', function(limit) {
  return Posts.find({}, {sort: {submitted: -1}, limit: limit});
});

Meteor.publish('bestPosts', function(limit) {
  return Posts.find({}, {sort: {votes: -1, submitted: -1}, limit: limit});
});
~~~
<%= caption "server/publications.js" %>

### Wielokrotna subskrypcja publikacji

////
 
////
 
////
 
<%= diagram "subscribetwice", "Dwukrotna subskrypcja tej samej publikacji", "pull-center" %>

////
 
~~~js
Meteor.publish('posts', function(options) {
  return Posts.find({}, options);
});
~~~

////
 
~~~js
Meteor.subscribe('posts', {submitted: -1, limit: 10});
Meteor.subscribe('posts', {baseScore: -1, submitted: -1, limit: 10});
~~~

////
 
////
 
### Wiele kolekcji w pojedyńczej subskrypcji

////
 
////
 
////
 
////
 
////
 
////
 
////
 
<%= diagram "multiplecollections", "Dwie kolekcje w jednej subskrypcji", "pull-center" %>

~~~js
Meteor.publish('topComments', function(topPostIds) {
  return Comments.find({postId: topPostIds});
});
~~~

////
 
////
 
~~~js
Meteor.publish('topPosts', function(limit) {
  var sub = this, commentHandles = [], postHandle = null;
  
  // prześlij dwa pierwsze komentarze załączone do postu
  function publishPostComments(postId) {
    var commentsCursor = Comments.find({postId: postId}, {limit: 2});
    commentHandles[post._id] = 
      Meteor.Collection._publishCursor(commentsCursor, sub, 'comments');
  }
    
  postHandle = Posts.find({}, {limit: limit}).observeChanges({
    added: function(id, post) {
      publishPostComments(post._id);
      sub.added('posts', id, post);
    },
    changed: function(id, fields) {
      sub.changed('posts', id, fields);
    },
    removed: function(id) {
      // przestań obserwować zmiany komentarzy do postu
      commentHandles[id] && commentHandles[id].stop();
      // usuń post
      sub.removed('posts', id);
    }
  });
  
  sub.ready();
  
  // upewnij się, że wszystko zostało posprzątane (uwaga: `_publishCursor`
  // robi to za nas za pomocą obserwatora komentarzy)
  sub.onStop(function() { postsHandle.stop(); });
});
~~~

////
 
////
 
////
 
### Łączenie różnych kolekcji

////
 
<%= diagram "linkedcollections", "Jedna kolekcja dla dwóch subskrypcji", "pull-center" %>

////
 
////
 
////
 
////
 
~~~js
  Meteor.publish('videos', function() {
    var sub = this;
    
    var videosCursor = Resources.find({type: 'video'});
    Meteor.Collection._publishCursor(videosCursor, sub, 'videos');
    
    // _publishCursor nie woła tego za nas w przypadku, gdy robimy to więcej niż raz.
    sub.ready();
  });
~~~

////
 
////
 
