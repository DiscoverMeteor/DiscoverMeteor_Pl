---
title: Kompensacja lagów
slug: latency-compensation
date: 0007/01/02
number: 7.5
sidebar: true
contents: jak zrozumieć kompensację lagów.|jak zwolnić swoją aplikację i zobaczyć co dzieje się naprawdę podczas jej pracy.|jak metody Metora wywołują się nawzajem
paragraphs: 28
---

W ostatnim rozdziale wprowadziliśmy nowy koncept w świecie Metora: **Metody**,

<%= diagram "latency1", "Bez kompensacji lagów", "pull-right" %>

Metoda w Meteorze umożliwia uruchomienie serii komand na serwerze w uporządkowany sposób. W naszym przykładzie, użytliśmy Metody ponieważ chcieliśmy upewnić się, że nowe posty zostaną otagowane imieniem autora i jego id oraz bieżącym czasem serwera.

Gdyby jednak Meteor uruchamiał Metody w sposób najbardziej podstawowy, mielibyśmy problem. Rozważ następującą sekwencję zdarzeń (uwaga: znaczniki czasu są losowymi wartościami, wybranymi wyłącznie dla celów demonstracyjnych):

- *+0ms:* Użytkownik klika na przycisk submit i przeglądarka wywołuje Metodę po stronie serwera.
- *+200ms:* Serwer wprowadza zmiany w bazie danych Mongo
- *+500ms:* Klient odbiera powyższe zmiany i uaktualnia interfejs użytkownika aby je odzwierciedlić.

Jeżeli tak działałby Meteor, występowałby bardzo krótki lag (przerwa) między wykonywaniem powyższych akcji i zobaczeniem wyników na ekranie (opóźnienie byłoby mniej lub bardziej widoczne w zależności od odległości do serwera). Nie możemy tak funkcjonować w nowoczesnej aplikacji webowej!

### Kompensacja Lagów

<%= diagram "latency2", "Z kompensacją lagów", "pull-right" %>

Aby obejść ten problem, Meteor wprowadza koncept **Kompensacji lagów**. Gdy zdefiniowaliśmy metodę `posts`, umieściliśmy ją w pliku znajdującym się w folderze `collections/`. Oznacza to, że jest dostępna zarówno dla serwera *oraz klienta* -- oraz to, że będzie uruchomiona na obu w tym samym czasie!

Gdy wywołujesz metodę serwerową, klient wysyła wywołanie do serwera i jednocześnie *symuluje* wykonanie akcji metody na kolekcjach znajdujących się u klienta. Nasza sekwencja zdarzeń wygląda teraz następująco:

- *+0ms:* ////
- *+0ms:* ////
- *+200ms:* ////
- *+500ms:* ////

////

### Observing Latency Compensation

////

////

////

~~~js
Meteor.methods({
  post: function(postAttributes) {
    // […]
    
    // pick out the whitelisted keys
    var post = _.extend(_.pick(postAttributes, 'url', 'message'), {
      title: postAttributes.title + (this.isSimulation ? '(client)' : '(server)'),
      userId: user._id, 
      author: user.username, 
      submitted: new Date().getTime()
    });
    
    // wait for 5 seconds
    if (! this.isSimulation) {
      var Future = Npm.require('fibers/future');
      var future = new Future();
      Meteor.setTimeout(function() {
        future.return();
      }, 5 * 1000);
      future.wait();
    }
    
    var postId = Posts.insert(post);
    
    return postId;
  }
});
~~~
<%= caption "collections/posts.js" %>
<%= highlight "6, 7, 13~22" %>

////

////

////

~~~js
Template.postSubmit.events({
  'submit form': function(event) {
    event.preventDefault();
    
    var post = {
      url: $(event.target).find('[name=url]').val(),
      title: $(event.target).find('[name=title]').val(),
      message: $(event.target).find('[name=message]').val()
    }
    
    Meteor.call('post', post, function(error, id) {
      if (error)
        return alert(error.reason);
    });
    Router.go('postsList');
  }
});
~~~
<%= caption "client/views/posts/post_submit.js" %>
<%= highlight "15" %>

<%= scommit "7-5-1", "Demonstrate the order that posts appear using a sleep." %>

////

<%= screenshot "s5-1", "Our post as first stored in the client collection" %>

////

<%= screenshot "s5-2", "Our post once the client receives the update from the server collection" %>

### Client Collection Methods

////

////

1. ////
2. ////
  
### Methods Calling Methods

////
 
////

////
